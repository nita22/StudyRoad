## 面向对象和JVM基础

##### java中的4种访问制权限：

* public：最大访问控制权限，对所有的类都可见。

* protected：同一包可见，不在同一个包的所有子类也可见。

* default：包访问权限，即同一个包中的类可以可见。默认不显式指定访问控制权限时就是default包访问控制权限。

* private：最严格的访问控制权限，仅该类本身可见，对外一切类都不可以访问(反射机制可以访问)。

  ​

##### 面向对象编程中两种对象组合方式——is-a 和 has-a：

(1).is-a组合：一个类继承具有相似功能的另一个类，根据需要在所继承的类基础上进行扩展。

优点：具有共同属性和方法的类可以将共享信息抽象到父类中，增强代码复用性，同时也是多态的基础。

缺点：子类中扩展的部分对父类不可见，另外如果共性比较少的时候使用继承会增加冗余代码。

(2).has-a组合：has-a组合是在一个类中引用另一个类作为其成员变量。

优点：可扩展性和灵活性高。在对象组合关系中应优先考虑has-a组合关系。

缺点：具有共性的类之间看不到派生关系。

​

##### 多态：

在面向对象编程中，子类中拥有和父类相同方法签名的方法称为子类方法覆盖父类方法，当调用子类方法的某个操作时，不必明确知道子类的具体类型，只需要将子类类型看作是父类的引用调用其操作方法，在运行时，JVM会根据引用对象的具体子类类型而调用应该的方法，这就是多态。

多态的基础是java面向对象编程的晚绑定机制。编程中有如下两种绑定机制：

* 早绑定：一般在非面向对象编程语言中使用，在程序编译时即计算出具体调用方法体的内存地址。


* 晚绑定：面向对象编程语言中经常使用，在程序编译时无法计算出具体调用方法体的内存地址，只进行方法参数类型和返回值类型的校验，在运行时才能确定具体要调用方法体的内存地址。

  ​

##### java单继承的优点：

相比于C++的多继承，java只支持类的单继承，java中的所有类的共同基类是Object类，Object类java类树的唯一根节点，这种单继承有以下好处：

(1).单继承可以确保所有的对象拥有某种共同的特性，这样对于JVM虚拟机对所有的类进行系统级的操作将提供方便，所有的java对象可以方便地在内存堆栈中创建，传递参数也变的更加方便简单。

(2).java的单继承使得实现垃圾回收器功能更加容易，因为可以确保JVM知道所有对象的类型信息。



##### 类型转换：

Java中有两种常见的类型转换：向上类型转换(upcast)和向下类型转换(downcast)：

* 向上类型转换(upcast)：

向上类型转换是将子类对象强制类型转换为父类类型，经典用法是面向对象的多态特性。向上类型转换时，子类对象的特性将不可见，只有子类从父类继承的特性仍然保持可见，向上类型转换时编译器会自动检查是否类型兼容，通常是安全的。

* 向下类型转换：

向下类型转换是将父类类型强制转换为子类类型，转换过后父类中不可见的子类特性又恢复可见性，向下类型转换时，编译器无法自动检测是否类型兼容，往往会产生类型转换错误的运行时异常，通常不安全。



##### java中5个存放数据的地方：

* 寄存器(Registers)：位于CPU内部，是速度最快的存储区，但是数量和容量有限。在java中不能直接操作寄存器。

* 栈(Stack)：栈位于通用随机访问存储器 (General random-access memory，RAM，内存) 中，通过处理器的栈指针访问，栈指针从栈顶向栈底分配内存，从栈底向栈顶释放内存。栈是仅次于寄存器的速度第二快的存储器，在java程序中，一般的8种基本类型数据和对象的引用通常存放在栈内存中，不通过new关键字的字符串对象也是存放在栈的字符串池中。栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。

* 堆(Heap)：也是位于通用随机访问存储器 (General random-access memory，RAM，内存) 中的共享内存池。Java的堆是一个运行时数据区，类的对象从中分配空间，凡是通过new关键字创建的对象都存放在堆内存中，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。

* 常量存储器(Constant storage)：java中的常量是存放在系统内嵌的只读存储器中(read-only memory,ROM)的。

* 非随机存储器(Non-RAM storage)：对于流对象和持久化对象，通常存放在程序外的存储器，如硬盘。

  ​

##### 移位运算：

左移运算符<<：将比特位左移指定位数，右边部分补0，左移一位相当于乘2。

右移运算符>>：将比特位右移指定位数，如果是正数，左边第一位(符号位)补0，其余位补0，如果是负数，左边第一位补1，其余位补0。右移一位相当于除2。

无符号右移运算符>>>：将比特位右移指定位数，不论是正数或者负数，左边移除位统统补0。



##### java中，比int类型小的原始类型(char、byte、short)进行数学运算或者位运算时，数据类型首先转换成int类型，然后进行相应的运算。

​

##### 方法重载(overloading)

方法同名，参数列表不同称为方法重载，注意方法的返回值类型不同不能作为方法重载。

​

##### java中的析构函数：

Java中没有像C/C++的析构函数，用来销毁不用的对象是否内存空间，只有以下三个方法用于通知垃圾回收器回收对象。

* **finalize( )**只是通知JVM的垃圾收集器当前的对象不再使用可以被回收了，但是垃圾回收器根据内存使用状况来决定是否回收。

  finalize()最有用的地方是在JNI调用本地方法时(C/C++方法)，调用本地方法的析构函数消耗对象释放函数。

* **System.gc()**是强制析构，显式通知垃圾回收器释放内存，但是垃圾回收器也不一定会立即执行，垃圾回收器根据当前内存使用状况和对象的生命周期自行决定是否回收。

* **RunTime.getRunTime().gc()**和**System.gc()**类似。

注意：这三个函数都不能保证垃圾回收器立即执行，推荐不要频繁使用。



##### 非内部类的访问控制权限只能是默认的包访问权限或者是public的，不能是protected和private的。内部类的访问控制权限可以是protected和private。

   ​

##### Java中的高精度数值类型：

   BigInteger和BigDecimal是java中的高精度数值类型，由于它们是用于包装java的基本数据类型，因此这两个高精度数值类型没有对应的原始类型。

   (1).BigInteger支持任意精度的整数，即使用BigInteger可以表示任意长度的整数值而在运算中不会因为范围溢出丢失信息。

   (2).BigDecimal支持任意精度的固定位数浮点数，可以用来精确计算货币等数值。

   普通的float和double型浮点数因为受到小数点位数限制，在运算时不能准确比较，只能以误差范围确定是否相等，而BigDecimal就可以支持固定位数的浮点数并进行精确计算。



##### Java中赋值运算：

   Java中赋值运算是把赋值运算符”=”右边的值简称右值拷贝到赋值运算符左边的变量，如a=b,即把b代表的变量或常量值复制给变量a,切记a只能是变量，不能说常量值。

   (1).原始类型赋值运算：

   Java中8种原始数据类型赋值运算是将赋值运算符右边的值拷贝到赋值运算符左边的变量中。

   原始类型赋值运算后，无论改变赋值运算符那一边的值，都不会影响赋值运算符另一边的值。

   (2).引用类型的赋值运算：

   Java中除了8种原始数据类型外，所有的数据类型都是对象类型，对象类型的赋值运算是操作引用，如a=b，把b引用赋值给a引用，即原本b引用指向的对象现在由a和b引用同时指向。

   引用赋值运算符又叫别名运算符，即它相当于给引用对象取了一个别名，其实引用的还是同一个对象。

   引用类型的赋值运算，如果赋值运算符任意一边的引用改变了被引用对象的值，赋值运算符另一边的引用也会受影响，因为两个引用指向的是同一个被引用的对象。